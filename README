ОПИСАНИЕ РАБОТЫ ПРОГРАММЫ VERTEXING

Программа состоит из нескольких частей, где каждая часть это отдельная папка с классами. Так же есть отдельная программа работающая с Федрой и скачивающая из файла linked-tracks.root (подробности будут ниже). 

Рассмотрим запуск и ход программы, попутно описывая некоторые части программы.
Первым делом надо воспользоваться отдельной програмкой VertexingByManual, в ней исполняемый файл называеться VertexingGPU. (странные названия из за того что програмка недоведена) В связи с невозможностью установить Федра в основной проект Vertexing на CMAKE, была создана эта програмка без CMAKE. Она скачивает linked_tracks.root посредством Федры, при этом сам файл треков должен лежать в корневом каталоге VertexingByManual. На выходе получиться файл downloaded_tracks.root. Этот файл это по сути те же треки, но без лишних параметров, что позволило значительно уменьшить размер файла и соответсвенно ускорить программу. Это одна из основных причин большой скорости работы программы - чем меньше весит каждый объект, тем быстрее он перекачиваеться по шинам внутри компьютера и тем чаще попадает в кэш память. Скачанные треки не имеют сегментов (надо поменять не много кода что бы их качать), а имеют только координаты начала и направления. Далее вручную нужно перенести файл downloaded_tracks.root в папку Vertexing/resources. После этого можно запускать программу Vertexing (в папке Vertexing/build/DSTauVertexing.exe) 
Рассмотрим ход программы. Программа начинаеться классически в методе main класса MainClass.cpp. Там создаеться объект AppLogic представляющий собой поток действий программы. Сразу же запускаеться метод AppLogic::findVertexes(). Этот метод первым делом создает объект Детектора в оперативной памяти и скачивает туда треки из downloaded_tracks.root. Вся обработка идет теперь только в оперативной памяти. Стоит отметить - детектор делиться на пространственные ячейки в которых будут храниться треки, сегменты, вершины. Размер ячейки вычисляеться изходя из плотности треков, что служит еще одним методом ускорения. Ячейка не должна быть слишком большая (при поиске соседа из соседней ячейки перебираются лишние треки в дальних углах ячейки) и не должна быть слишком маленькая (при поиске соседа не должно быть обращений к пустым ячейкам). Попутно так же при загрузке треков отсортировуются треки с малым углом. Они будут загружены в детектор позже, что немного ускорило обработку, так как при поиске соседа нет обращений к прямым трекам. Далее используеться объект класса VertexSearcher, который по сути представляет собой алгоритм поиска вершины. Объект AppLogic это "пользователь" VertexSearcher, DetectorVolume, Downloader и прочих, который создает детектор поделенный на соотвующее число ячеек, загружает в детектор треки, запускает алгоритм, выводит результаты и тайминг. Это сделано для разделения ответсвенности каждого из классов, что позволит легко расширить функционал.

Рассмотрим алгоритм поиска вершин в классе VertexSearcher. Берется каждый по очереди трек, к нему беруться все соседи в радиусе задаваемом переменными NEIGHBOR_TRACK_XY(или Z)_DISTANCE около 1000 микрон, где с каждым соседом мы ищем середину общего перпендикуляра на продолжениях треков. Это стандартная операция из аналитической геометрии. Мы смотрим длинну этого перпендикуляра (TRACKS_PERPENDICULAR около 10 микрон). Далее смотрим на сколько далеко эта точка отошла от начала треков (переменная VERTEX_TO_TRACK_Z_DIST около 1000 микрон). Этими переменными мы отсекаем не физичные вершины, так как по сути любая пара прямых будет иметь некоторый перпендикуляр и соотвественно его середину, но размер перпендикуляра и удаленность от начала треков и покажет нам что это просто математическое совпадение. Далее уже к найденной вершине беруться соседи (в радиусе NEIGHBOR_TRACK_XY(или Z)_DISTANCE около 1000 микрон), проверяеться прицельный-параметр между вершиной и треком (IMPACT_PARAMETER около 15 микрон), и если трек проходит этот CUT, то он присоеденяеться к вершине и выбывает из дальнейшего поиска. То есть трек помечаеться специальным булеаном (track->isExcluded()), и в дальнейшем уже не может быть присоеденен к другой вершине и так же с ним не будет искаться общий перпендикуляр. Это сильно ускоряет программу, так как по ходу алгоритма буквально с первой пары треков образовавших вершину, к ней тут же присоеденяеться большая часть соседних треков, они ислючаются из поиска, с ними не происходит образования новых вершин и т.д. Существует проблема, что если две реальные вершины образовались рядом друг с другом, то такой алгоритм может грубо присоеденить к некоторой одной вершине все треки, свои и чужие. Необходимо уточнять отдельным алгоритмом. Стоит отметить, что алгоритмы нахождения общей вершины, вычисления прицельного параметра и некоторые другие выполнены векторными инструкциями ЦПУ. Это позволило многократно ускорить программу, так как переборов между соседями (и соответсвенно вычислений) происходит очень очень много, то это являлось узким горлышком. Векторные инструкции ЦПУ позволяют ускорить типичные математические векторные операции, так как подобная операция внутри ЦПУ использует специальные регистры и выполняеться за один такт процессора, вместо классических операций где каждый элемент вектора требует отдельной операции ЦПУ. 
После нахождения вершин с присоедененными треками мы двигаем каждую вершину так, что бы сумма её прицельных параметров с каждым её треком была минимальна. Это делаеться пакетом ROOT TMinuit. В заключении алгоритма удаляються все вершины имеющие менее 4-х дочерних треков. Далее вершины с их дочерними треками выгружаются в файл. 
Напомним еще раз - так как каждый класс отвечает за своё, и если надо поменять цепочку действий программы, то нужно менять методы в AppLogic class, если нужно выводить в некоторый другой формат файла, то нужно менять метод downloadVertexesToFile в классе наследнике от IDownloader ( в нашем случае это класс FedraDownloader) Можно легко переопределить наследника IDownloader со своими полностью другими методами, это не повлияет на другие классы, так как они не зависят от реализации, а просто пользуються интерфейсом IDownloader. Если нужно поменять алгоритм поиска, то это VertexSearcher. И так далее. Можно реализовать загрузку из Федры в FedraDwonloader::downloadTracksFromFile если удасться подключить Федру. То есть задумка в том что каждый новый функционал добавляеться в соответсвующий класс и ни как не влияет на пользователей этого класса и на остальные части программы.

Рассмотрим некоторые замечания по пользованию объектом DetectorVolume представляющим собой детектор с ячейками. 
Этот объект являеться хранилищем треков, их сегментов, вершин. Детектор имеет типичный набор методов типа добавления трека или вершины, удаления трека или вершины, проверки есть ли такая вершина в некоторой точке координат, поиск и взятие вершины в некоторой точке. А также взятие всех треков или вершин вокруг некоторой точки (именно это используеться при поиске соседей), подсчета всех треков или вершин в детекторе и некотрые другие методы. При добавлении трека или вершины в детектор, он сам вычисляет нужную ячейку изходя из координат этого трека или вершины. Это позволяет отсортировать произвольный набор треков или вершин по ячейкам, что потом даст мгновенную скорость поиска в некоторой координатной точке. Каждая ячейка хранит в себе массив треков и массив вершин. В идеале для скорости доступа нужно стремиться что бы ячейка имела в среднем по одному объекту внутри себя. Если ячейка большая то при запросе объекта из нее будет происходить поиск еще внутри массива, если ячейка маленькая, то такие пустые ячейки так же отнимают время на поиск нужного обьекта по ним. Вычисление оптимального размера ячейки происходит в CalculationAndAlgorithms::calculateCellSizeFromTracksCount. Далее - при запросе например всех треков в некотором радиусе детектор возвращает массив указателей на объекты. Каждый такой указатель не может изменить координаты объекта! Это сделано для того что бы пользователь не мог извне детектора передвинуть трек или вершину, так как при передвижении может измениться ячейка которая должна хранить объект, что разломает программу. Поэтому например в алгоритме где мы двигаем вершину минимизируя сумму ее прицельных параметорв, мы каждый раз создаем новую передвинутую вершину, добавляем эту новую вершину в детектор, а старую вершину обязательно удаляем что бы не было дубликатов (этот метод желательно реализовать в нутри детектора по типу UPDATE в базах данных). Такой подход почти не заметно замедляет программу, так как на выходе вершин остаеться довольно мало. А объекты типа треков или сегментов впринципе не могут быть передвинуты куда либо.
В программе есть некотроые моменты которые могут показаться неоптимальными. Например создание вектора указателей на вершины и передача этого вектора не по ссылке, а по значению. Но это не требует изменений, так как компилятор сам оптимизирует и уберет промежуточные объекты. Так же для небольшого ускорения следует переписать некоторые методы на С++17 с применением Optional.

